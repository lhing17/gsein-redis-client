export const lang = {
  nav: {
    connection: 'Connection',
    cheatsheet: 'Cheatsheet',
    versions: 'Versions',
    about: 'About'
  },
  header: {
    newConnection: 'New Connection',
    removeConnection: 'Remove Connection',
    connectionProperties: 'Connection Properties',
    openTerminal: 'Open Terminal',
    refresh: 'Refresh',
    switchLanguage: 'Switch Languages'
  },
  dialog: {
    host: 'Host',
    port: 'Port',
    auth: 'Auth',
    name: 'Name',
    separator: 'Separator',
    cancel: 'Cancel',
    confirm: 'Confirm',
    testConnection: 'Test Connection',
    save: 'Save',
    operation: 'Operation',
    edit: 'Edit',
    delete: 'Delete',
    hint: 'Hint',
    updateHint: 'Confirm to change key from {originalKey} to {newKey}?',
    updateFailure: 'Fail to update',
    updateTtlHint: 'Set TTL<=0 will delete this key, please confirm',
    deleteHint: 'Confirm to delete?',
    deleteKeyHint: 'Confirm to delete {key}？',
    newLine: 'Add New Line',
    editLine: 'Edit Line',
    leaveMessage: 'Message',
    leaveMessageHolder: 'Please leave you suggestions',
    contact: 'Contact (optional)',
    contactHolder: 'QQ/Email',
    submit: 'Submit',
    messageTitle: 'Feedback',
    thanksForFeedback: 'Thanks for your feedback!',
    success: 'Success',
    keyName: 'Name',
    keyType: 'Type',
    enterKeyName: 'Enter key name',
    selectKeyType: 'Select key type'
  },
  about: {
    name: 'Gsein Redis Client',
    power: 'Powered by G. Seinfeld',
    copyright: 'copyright © 2021 G. Seinfeld',
    checkUpdate: 'Check Update',
    feedback: 'Feedback',
    manual: 'Manual',
    projectHome: 'Project Home'
  },
  versions: {
    changelog: 'Change Log',
    v1_0: {
      title: 'March 2021 - v1.0',
      content: 'Initial release'
    }
  },
  cheatsheet: {
    name: 'Enter order name',
    type: 'Select type',
    search: 'Search'
  },
  redisInfo: {
    server: 'Server',
    version: 'Redis Version: ',
    os: 'OS: ',
    processId: 'Process ID: ',
    memory: 'Memory',
    used: 'Used Memory: ',
    peak: 'Used Memory Peak: ',
    usedLua: 'Used Memory Lua: ',
    status: 'Status',
    connected: 'Connected Clients: ',
    connectionsReceived: 'Connections Received: ',
    commandsProcessed: 'Commands Processed: ',
    keyValue: 'Key Space',
    completeInfo: 'Full Redis Information'
  },
  connection: {
    loadMore: 'Load More',
    newKey: 'New key',
    valid: 'Valid',
    invalid: 'Invalid',
    invalidConnection: 'Invalid connection',
    refreshSuccess: 'Refresh successfully',
    refreshFail: 'Fail to refresh'
  },
  commands: {
    acl_load: 'Reload the ACLs from the configured ACL file',
    acl_save: 'Save the current ACL rules in the configured ACL file',
    acl_list: 'List the current ACL rules in ACL config file format',
    acl_users: 'List the username of all the configured ACL rules',
    acl_getuser: 'Get the rules for a specific ACL user',
    acl_setuser: 'Modify or create the rules for a specific ACL user',
    acl_deluser: 'Remove the specified ACL users and the associated rules',
    acl_cat: 'List the ACL categories or the commands inside a category',
    acl_genpass: 'Generate a pseudorandom secure password to use for ACL users',
    acl_whoami: 'Return the name of the user associated to the current connection',
    acl_log: 'List latest events denied because of ACLs in place',
    acl_help: 'Show helpful text about the different subcommands',
    append: 'Append a value to a key',
    auth: 'Authenticate to the server',
    bgrewriteaof: 'Asynchronously rewrite the append-only file',
    bgsave: 'Asynchronously save the dataset to disk',
    bitcount: 'Count set bits in a string',
    bitfield: 'Perform arbitrary bitfield integer operations on strings',
    bitop: 'Perform bitwise operations between strings',
    bitpos: 'Find first bit set or clear in a string',
    blpop: 'Remove and get the first element in a list, or block until one is available',
    brpop: 'Remove and get the last element in a list, or block until one is available',
    brpoplpush: 'Pop an element from a list, push it to another list and return it; or block until one is available',
    blmove: 'Pop an element from a list, push it to another list and return it; or block until one is available',
    bzpopmin: 'Remove and return the member with the lowest score from one or more sorted sets, or block until one is available',
    bzpopmax: 'Remove and return the member with the highest score from one or more sorted sets, or block until one is available',
    client_caching: 'Instruct the server about tracking or not keys in the next request',
    client_id: 'Returns the client ID for the current connection',
    client_info: 'Returns information about the current client connection.',
    client_kill: 'Kill the connection of a client',
    client_list: 'Get the list of client connections',
    client_getname: 'Get the current connection name',
    client_getredir: 'Get tracking notifications redirection client ID if any',
    client_unpause: 'Resume processing of clients that were paused',
    client_pause: 'Stop processing commands from clients for some time',
    client_reply: 'Instruct the server whether to reply to commands',
    client_setname: 'Set the current connection name',
    client_tracking: 'Enable or disable server assisted client side caching support',
    client_trackinginfo: 'Return information about server assisted client side caching for the current connection',
    client_unblock: 'Unblock a client blocked in a blocking command from a different connection',
    cluster_addslots: 'Assign new hash slots to receiving node',
    cluster_bumpepoch: 'Advance the cluster config epoch',
    cluster_count_failure_reports: 'Return the number of failure reports active for a given node',
    cluster_countkeysinslot: 'Return the number of local keys in the specified hash slot',
    cluster_delslots: 'Set hash slots as unbound in receiving node',
    cluster_failover: 'Forces a replica to perform a manual failover of its master.',
    cluster_flushslots: 'Delete a node\'s own slots information',
    cluster_forget: 'Remove a node from the nodes table',
    cluster_getkeysinslot: 'Return local key names in the specified hash slot',
    cluster_info: 'Provides info about Redis Cluster node state',
    cluster_keyslot: 'Returns the hash slot of the specified key',
    cluster_meet: 'Force a node cluster to handshake with another node',
    cluster_myid: 'Return the node id',
    cluster_nodes: 'Get Cluster config for the node',
    cluster_replicate: 'Reconfigure a node as a replica of the specified master node',
    cluster_reset: 'Reset a Redis Cluster node',
    cluster_saveconfig: 'Forces the node to save cluster state on disk',
    cluster_set_config_epoch: 'Set the configuration epoch in a new node',
    cluster_setslot: 'Bind a hash slot to a specific node',
    cluster_slaves: 'List replica nodes of the specified master node',
    cluster_replicas: 'List replica nodes of the specified master node',
    cluster_slots: 'Get array of Cluster slot to node mappings',
    command: 'Get array of Redis command details',
    command_count: 'Get total number of Redis commands',
    command_getkeys: 'Extract keys given a full Redis command',
    command_info: 'Get array of specific Redis command details',
    config_get: 'Get the value of a configuration parameter',
    config_rewrite: 'Rewrite the configuration file with the in memory configuration',
    config_set: 'Set a configuration parameter to the given value',
    config_resetstat: 'Reset the stats returned by INFO',
    copy: 'Copy a key',
    dbsize: 'Return the number of keys in the selected database',
    debug_object: 'Get debugging information about a key',
    debug_segfault: 'Make the server crash',
    decr: 'Decrement the integer value of a key by one',
    decrby: 'Decrement the integer value of a key by the given number',
    del: 'Delete a key',
    discard: 'Discard all commands issued after MULTI',
    dump: 'Return a serialized version of the value stored at the specified key.',
    echo: 'Echo the given string',
    eval: 'Execute a Lua script server side',
    evalsha: 'Execute a Lua script server side',
    exec: 'Execute all commands issued after MULTI',
    exists: 'Determine if a key exists',
    expire: 'Set a key\'s time to live in seconds',
    expireat: 'Set the expiration for a key as a UNIX timestamp',
    failover: 'Start a coordinated failover between this server and one of its replicas.',
    flushall: 'Remove all keys from all databases',
    flushdb: 'Remove all keys from the current database',
    geoadd: 'Add one or more geospatial items in the geospatial index represented using a sorted set',
    geohash: 'Returns members of a geospatial index as standard geohash strings',
    geopos: 'Returns longitude and latitude of members of a geospatial index',
    geodist: 'Returns the distance between two members of a geospatial index',
    georadius: 'Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point',
    georadiusbymember: 'Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member',
    geosearch: 'Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle.',
    geosearchstore: 'Query a sorted set representing a geospatial index to fetch members inside an area of a box or a circle, and store the result in another key.',
    get: 'Get the value of a key',
    getbit: 'Returns the bit value at offset in the string value stored at key',
    getdel: 'Get the value of a key and delete the key',
    getex: 'Get the value of a key and optionally set its expiration',
    getrange: 'Get a substring of the string stored at a key',
    getset: 'Set the string value of a key and return its old value',
    hdel: 'Delete one or more hash fields',
    hello: 'Handshake with Redis',
    hexists: 'Determine if a hash field exists',
    hget: 'Get the value of a hash field',
    hgetall: 'Get all the fields and values in a hash',
    hincrby: 'Increment the integer value of a hash field by the given number',
    hincrbyfloat: 'Increment the float value of a hash field by the given amount',
    hkeys: 'Get all the fields in a hash',
    hlen: 'Get the number of fields in a hash',
    hmget: 'Get the values of all the given hash fields',
    hmset: 'Set multiple hash fields to multiple values',
    hset: 'Set the string value of a hash field',
    hsetnx: 'Set the value of a hash field, only if the field does not exist',
    hrandfield: 'Get one or multiple random fields from a hash',
    hstrlen: 'Get the length of the value of a hash field',
    hvals: 'Get all the values in a hash',
    incr: 'Increment the integer value of a key by one',
    incrby: 'Increment the integer value of a key by the given amount',
    incrbyfloat: 'Increment the float value of a key by the given amount',
    info: 'Get information and statistics about the server',
    lolwut: 'Display some computer art and the Redis version',
    keys: 'Find all keys matching the given pattern',
    lastsave: 'Get the UNIX time stamp of the last successful save to disk',
    lindex: 'Get an element from a list by its index',
    linsert: 'Insert an element before or after another element in a list',
    llen: 'Get the length of a list',
    lpop: 'Remove and get the first elements in a list',
    lpos: 'Return the index of matching elements on a list',
    lpush: 'Prepend one or multiple elements to a list',
    lpushx: 'Prepend an element to a list, only if the list exists',
    lrange: 'Get a range of elements from a list',
    lrem: 'Remove elements from a list',
    lset: 'Set the value of an element in a list by its index',
    ltrim: 'Trim a list to the specified range',
    memory_doctor: 'Outputs memory problems report',
    memory_help: 'Show helpful text about the different subcommands',
    memory_malloc_stats: 'Show allocator internal stats',
    memory_purge: 'Ask the allocator to release memory',
    memory_stats: 'Show memory usage details',
    memory_usage: 'Estimate the memory usage of a key',
    mget: 'Get the values of all the given keys',
    migrate: 'Atomically transfer a key from a Redis instance to another one.',
    module_list: 'List all modules loaded by the server',
    module_load: 'Load a module',
    module_unload: 'Unload a module',
    monitor: 'Listen for all requests received by the server in real time',
    move: 'Move a key to another database',
    mset: 'Set multiple keys to multiple values',
    msetnx: 'Set multiple keys to multiple values, only if none of the keys exist',
    multi: 'Mark the start of a transaction block',
    object: 'Inspect the internals of Redis objects',
    persist: 'Remove the expiration from a key',
    pexpire: 'Set a key\'s time to live in milliseconds',
    pexpireat: 'Set the expiration for a key as a UNIX timestamp specified in milliseconds',
    pfadd: 'Adds the specified elements to the specified HyperLogLog.',
    pfcount: 'Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).',
    pfmerge: 'Merge N different HyperLogLogs into a single one.',
    ping: 'Ping the server',
    psetex: 'Set the value and expiration in milliseconds of a key',
    psubscribe: 'Listen for messages published to channels matching the given patterns',
    pubsub: 'Inspect the state of the Pub/Sub subsystem',
    pttl: 'Get the time to live for a key in milliseconds',
    publish: 'Post a message to a channel',
    punsubscribe: 'Stop listening for messages posted to channels matching the given patterns',
    quit: 'Close the connection',
    randomkey: 'Return a random key from the keyspace',
    readonly: 'Enables read queries for a connection to a cluster replica node',
    readwrite: 'Disables read queries for a connection to a cluster replica node',
    rename: 'Rename a key',
    renamenx: 'Rename a key, only if the new key does not exist',
    reset: 'Reset the connection',
    restore: 'Create a key using the provided serialized value, previously obtained using DUMP.',
    role: 'Return the role of the instance in the context of replication',
    rpop: 'Remove and get the last elements in a list',
    rpoplpush: 'Remove the last element in a list, prepend it to another list and return it',
    lmove: 'Pop an element from a list, push it to another list and return it',
    rpush: 'Append one or multiple elements to a list',
    rpushx: 'Append an element to a list, only if the list exists',
    sadd: 'Add one or more members to a set',
    save: 'Synchronously save the dataset to disk',
    scard: 'Get the number of members in a set',
    script_debug: 'Set the debug mode for executed scripts.',
    script_exists: 'Check existence of scripts in the script cache.',
    script_flush: 'Remove all the scripts from the script cache.',
    script_kill: 'Kill the script currently in execution.',
    script_load: 'Load the specified Lua script into the script cache.',
    sdiff: 'Subtract multiple sets',
    sdiffstore: 'Subtract multiple sets and store the resulting set in a key',
    select: 'Change the selected database for the current connection',
    set: 'Set the string value of a key',
    setbit: 'Sets or clears the bit at offset in the string value stored at key',
    setex: 'Set the value and expiration of a key',
    setnx: 'Set the value of a key, only if the key does not exist',
    setrange: 'Overwrite part of a string at key starting at the specified offset',
    shutdown: 'Synchronously save the dataset to disk and then shut down the server',
    sinter: 'Intersect multiple sets',
    sinterstore: 'Intersect multiple sets and store the resulting set in a key',
    sismember: 'Determine if a given value is a member of a set',
    smismember: 'Returns the membership associated with the given elements for a set',
    slaveof: 'Make the server a replica of another instance, or promote it as master. Deprecated starting with Redis 5. Use REPLICAOF instead.',
    replicaof: 'Make the server a replica of another instance, or promote it as master.',
    slowlog: 'Manages the Redis slow queries log',
    smembers: 'Get all the members in a set',
    smove: 'Move a member from one set to another',
    sort: 'Sort the elements in a list, set or sorted set',
    spop: 'Remove and return one or multiple random members from a set',
    srandmember: 'Get one or multiple random members from a set',
    srem: 'Remove one or more members from a set',
    stralgo: 'Run algorithms (currently LCS) against strings',
    strlen: 'Get the length of the value stored in a key',
    subscribe: 'Listen for messages published to the given channels',
    sunion: 'Add multiple sets',
    sunionstore: 'Add multiple sets and store the resulting set in a key',
    swapdb: 'Swaps two Redis databases',
    sync: 'Internal command used for replication',
    psync: 'Internal command used for replication',
    time: 'Return the current server time',
    touch: 'Alters the last access time of a key(s). Returns the number of existing keys specified.',
    ttl: 'Get the time to live for a key',
    type: 'Determine the type stored at key',
    unsubscribe: 'Stop listening for messages posted to the given channels',
    unlink: 'Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.',
    unwatch: 'Forget about all watched keys',
    wait: 'Wait for the synchronous replication of all the write commands sent in the context of the current connection',
    watch: 'Watch the given keys to determine execution of the MULTI/EXEC block',
    zadd: 'Add one or more members to a sorted set, or update its score if it already exists',
    zcard: 'Get the number of members in a sorted set',
    zcount: 'Count the members in a sorted set with scores within the given values',
    zdiff: 'Subtract multiple sorted sets',
    zdiffstore: 'Subtract multiple sorted sets and store the resulting sorted set in a new key',
    zincrby: 'Increment the score of a member in a sorted set',
    zinter: 'Intersect multiple sorted sets',
    zinterstore: 'Intersect multiple sorted sets and store the resulting sorted set in a new key',
    zlexcount: 'Count the number of members in a sorted set between a given lexicographical range',
    zpopmax: 'Remove and return members with the highest scores in a sorted set',
    zpopmin: 'Remove and return members with the lowest scores in a sorted set',
    zrandmember: 'Get one or multiple random elements from a sorted set',
    zrangestore: 'Store a range of members from sorted set into another key',
    zrange: 'Return a range of members in a sorted set',
    zrangebylex: 'Return a range of members in a sorted set, by lexicographical range',
    zrevrangebylex: 'Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.',
    zrangebyscore: 'Return a range of members in a sorted set, by score',
    zrank: 'Determine the index of a member in a sorted set',
    zrem: 'Remove one or more members from a sorted set',
    zremrangebylex: 'Remove all members in a sorted set between the given lexicographical range',
    zremrangebyrank: 'Remove all members in a sorted set within the given indexes',
    zremrangebyscore: 'Remove all members in a sorted set within the given scores',
    zrevrange: 'Return a range of members in a sorted set, by index, with scores ordered from high to low',
    zrevrangebyscore: 'Return a range of members in a sorted set, by score, with scores ordered from high to low',
    zrevrank: 'Determine the index of a member in a sorted set, with scores ordered from high to low',
    zscore: 'Get the score associated with the given member in a sorted set',
    zunion: 'Add multiple sorted sets',
    zmscore: 'Get the score associated with the given members in a sorted set',
    zunionstore: 'Add multiple sorted sets and store the resulting sorted set in a new key',
    scan: 'Incrementally iterate the keys space',
    sscan: 'Incrementally iterate Set elements',
    hscan: 'Incrementally iterate hash fields and associated values',
    zscan: 'Incrementally iterate sorted sets elements and associated scores',
    xinfo: 'Get information on streams and consumer groups',
    xadd: 'Appends a new entry to a stream',
    xtrim: 'Trims the stream to (approximately if \'~\' is passed) a certain size',
    xdel: 'Removes the specified entries from the stream. Returns the number of items actually deleted, that may be different from the number of IDs passed in case certain IDs do not exist.',
    xrange: 'Return a range of elements in a stream, with IDs matching the specified IDs interval',
    xrevrange: 'Return a range of elements in a stream, with IDs matching the specified IDs interval, in reverse order (from greater to smaller IDs) compared to XRANGE',
    xlen: 'Return the number of entries in a stream',
    xread: 'Return never seen elements in multiple streams, with IDs greater than the ones reported by the caller for each stream. Can block.',
    xgroup: 'Create, destroy, and manage consumer groups.',
    xreadgroup: 'Return new entries from a stream using a consumer group, or access the history of the pending entries for a given consumer. Can block.',
    xack: 'Marks a pending message as correctly processed, effectively removing it from the pending entries list of the consumer group. Return value of the command is the number of messages successfully acknowledged, that is, the IDs we were actually able to resolve in the PEL.',
    xclaim: 'Changes (or acquires) ownership of a message in a consumer group, as if the message was delivered to the specified consumer.',
    xautoclaim: 'Changes (or acquires) ownership of messages in a consumer group, as if the messages were delivered to the specified consumer.',
    xpending: 'Return information and entries from a stream consumer group pending entries list, that are messages fetched but never acknowledged.',
    latency_doctor: 'Return a human readable latency analysis report.',
    latency_graph: 'Return a latency graph for the event.',
    latency_history: 'Return timestamp-latency samples for the event.',
    latency_latest: 'Return the latest latency samples for all events.',
    latency_reset: 'Reset latency data for one or more events.',
    latency_help: 'Show helpful text about the different subcommands.'
  }
}
